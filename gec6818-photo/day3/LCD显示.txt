

一、LCD显示
1.硬件参数
	屏幕分辨率：800*480
	800*480：一行有800个像素点，一共有480行
	像素点：能够显示一种颜色的点
	颜色：
		所有的颜色都是由 R G B 三种基本的三原色组成
	原色：
		单一的颜色
		那么单一的颜色是有程度之分吧？
		G：浅绿、shi绿、青青草原绿

		量化：
			取0-255这个区间的数字，每一个数字代表一个等级的原色，
		一共有256个等级。

		刚好可以用一个unsigned char类型的数据去描述一个原色

	现在为了增加图片的立体感，在三原色的基础上，增加了透明度的概念 A
	透明度也是有等级之分，也分为0-255这个区间。

	开发板显示屏上的像素点就是 ARGB 型
	ARGB 标准色
	可以用一个 int 类型的数据去描述一个标准色：
		最红色：0x 00 ff 00 00
		黑色  : 0x 00 00 00 00
		白色  : 0x 00 ff ff ff
		
	一个颜色我们就可以定义一个int 的变量去表示
		int color = 0x0000ff00; // 一个最绿色
		
2.怎么把颜色显示到开发板上？
	linux提供一块缓冲区，这块缓冲区保存屏幕上每一个像素点的信息。
		我们向这块缓冲区写入颜色，即给屏幕上的像素点赋值，缓冲区的驱动
	就会自动把颜色同步到硬件上。
		这块缓冲区就是帧缓冲：
			文件接口："/dev/fb0"

练习：动手给这个开发板染一个颜色。

有可能遇到的问题：
	看到屏幕”烂掉了“，出现一些黑色裂缝、黑点，过一会就好了
	原因：硬件不能及时同步像素点的数据。
		  是write的锅，它是一个系统调用函数，消耗的资源比较大。

		一个对象的地址，是可以通过指针去修改对象的内容。
	那么就可以通过获取帧缓冲的地址，去操作帧缓冲的内容。

	linux提供了一个内存映射的功能。
	
3.内存映射 mmap
	
	函数原型：
		#include <sys/mman.h>

		void *mmap(	void *addr, 	// 要映射空间的地址，一般填 NULL
					size_t length,  // 要映射空间的大小(字节)，800*480*4
					int prot, 		// 映射的权限：PROT_READ | PROT_WRITE
					int flags,		// 映射的属性：MAP_SHARED 对其他应用共享
					int fd, 		// 打开的那个文件的文件描述符
					off_t offset	// 偏移量 0
					);
	返回值：
		成功 返回映射的首地址
		失败 返回NULL
		
		
		int munmap(	void *addr,    // 映射的那段空间的首地址
					size_t length  // 解映射长度 800*480*4
					);

	假设要将屏幕上的第一行的第一个像素点变绿
		*plcd = 0xff00;
	假设要将屏幕上的第一行的第二个像素点变绿
		*(plcd+1) = 0xff00;
	假设要将屏幕上的第一行的第x个像素点变绿
		*(plcd+x) = 0xff00;
	假设要将屏幕上的第二行的第一个像素点变绿
		*(plcd+800) = 0xff00;
	假设要将屏幕上的第y行的第一个像素点变绿
		*(plcd+800*y) = 0xff00;
	假设要将屏幕上的(x, y)这个像素点变绿
		*(plcd + 800*y + x) = 0xff00;


作业：程序实现画一个黄色矩形，封装成一个函数。

















